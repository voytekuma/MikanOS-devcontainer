## 割り込み
- ポーリング方式は効率が悪い
    - 割り込みはイベント通知を受けて処理を行うことができる
- x86_64アーキテクチャの割り込み
    - 事前準備
        - イベント発生時に実行する割り込みハンドラの準備
        - IDT（割り込み記述しテーブル）に登録
    - イベント発生時
        - ハードウェアがCPUにイベント通知
        - CPUは現在処理を中断、登録された割り込みハンドラに処理を移す
        - 割り込みハンドラ終了後に元の処理を再開
- 割り込みハンドラ
    - 割り込み発生時に実行される関数

<br>

## 割り込みハンドラ
- \_\_attribute__((interrupt))
    - 直後に定義される関数が割り込みハンドラであることをコンパイラに伝える
    - コンパイラが割り込みハンドラに必要となる前処理と後処理を挿入してくれる
- 割り込みの終了
    - 0xfee000b0番地（EndOfInterruptレジスタ）に何かしら書き込み
    - なぜメインメモリに書き込むだけでCPUに伝わる？
        - 0xfee0000 ~ 0xfee00400はCPUのレジスタに置かれている
    - volatile修飾子
        - コンパイラの最適化の対象にならない
        - どこからも読み込みされない変数への書き込みは省略される可能性がある
        - レジスタへの書き込みは書くこと自体に意味がある

<br>

## 割り込みベクタ
- 割り込みの種類によって異なる割り込み要因番号（割り込みベクタ）を割り振って管理する
- 割当は決まっているものもあれば、OS作者が割り振っていいものもある
    - 0除算による割り込みは0と割り振られている
- ビットフィールド
    - 通常の構造体は1バイト単位でしか名前をつけられない
    - ビットフィールドを使うと1ビット単位で名前をつけられる
    - 無名構造体にビット幅以上の幅を持つ符号なし整数で *フィールド名 : ビット幅* と書く 
- IDT(割り込み記述子テーブル)
    - 割り込み番号と割り込みハンドラを対応付けるテーブル(0~255)
- \_\_attribute__((packed))
    - 構造体の各フィールドを詰めて配置するためのコンパイラ拡張
    - ハードウェアの仕様で定まったデータ構造を構造体として表現する場合はパディングが挿入されないように

<br>

## 割り込み記述子の設定
- IDTのxHCI用の割り込みベクタ(0x40)に対してハンドラを登録
- 設定したIDTの場所をCPUに教える
    - サイズと場所を直接指定するのではなく、2つの値を書き込んだ10バイトのメモリ領域を指定する

<br>

## MSI割り込み
- xHCIの割り込み発生方法は、MSIを採用している。
- MSI(Message Signaled Interrputs)
    - メモリバスへの書き込み動作により割り込みを発生させる
    - 特定のメモリアドレス(Message Address)に対して32ビットの値（Message Data）を書き込む
    - フォーマットはCPU側の仕様で規定されいてる
- Destination ID
    - Message Addressのフィールド
    - 割り込みを通知するCPUコア番号を指定できる
- Vector
    - Message Dataのフィールド
    - 割り込みハンドラを設定した割り込み記述子の番号と同じ番号を指定

                    